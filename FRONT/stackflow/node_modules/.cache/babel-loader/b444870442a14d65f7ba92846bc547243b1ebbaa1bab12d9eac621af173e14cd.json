{"ast":null,"code":"var cookie = {};\n\n/*!\r\n * cookie\r\n * Copyright(c) 2012-2014 Roman Shtylman\r\n * Copyright(c) 2015 Douglas Christopher Wilson\r\n * MIT Licensed\r\n */\n\nvar hasRequiredCookie;\nfunction requireCookie() {\n  if (hasRequiredCookie) return cookie;\n  hasRequiredCookie = 1;\n\n  /**\r\n   * Module exports.\r\n   * @public\r\n   */\n\n  cookie.parse = parse;\n  cookie.serialize = serialize;\n\n  /**\r\n   * Module variables.\r\n   * @private\r\n   */\n\n  var __toString = Object.prototype.toString;\n  var __hasOwnProperty = Object.prototype.hasOwnProperty;\n\n  /**\r\n   * RegExp to match cookie-name in RFC 6265 sec 4.1.1\r\n   * This refers out to the obsoleted definition of token in RFC 2616 sec 2.2\r\n   * which has been replaced by the token definition in RFC 7230 appendix B.\r\n   *\r\n   * cookie-name       = token\r\n   * token             = 1*tchar\r\n   * tchar             = \"!\" / \"#\" / \"$\" / \"%\" / \"&\" / \"'\" /\r\n   *                     \"*\" / \"+\" / \"-\" / \".\" / \"^\" / \"_\" /\r\n   *                     \"`\" / \"|\" / \"~\" / DIGIT / ALPHA\r\n   */\n\n  var cookieNameRegExp = /^[!#$%&'*+\\-.^_`|~0-9A-Za-z]+$/;\n\n  /**\r\n   * RegExp to match cookie-value in RFC 6265 sec 4.1.1\r\n   *\r\n   * cookie-value      = *cookie-octet / ( DQUOTE *cookie-octet DQUOTE )\r\n   * cookie-octet      = %x21 / %x23-2B / %x2D-3A / %x3C-5B / %x5D-7E\r\n   *                     ; US-ASCII characters excluding CTLs,\r\n   *                     ; whitespace DQUOTE, comma, semicolon,\r\n   *                     ; and backslash\r\n   */\n\n  var cookieValueRegExp = /^(\"?)[\\u0021\\u0023-\\u002B\\u002D-\\u003A\\u003C-\\u005B\\u005D-\\u007E]*\\1$/;\n\n  /**\r\n   * RegExp to match domain-value in RFC 6265 sec 4.1.1\r\n   *\r\n   * domain-value      = <subdomain>\r\n   *                     ; defined in [RFC1034], Section 3.5, as\r\n   *                     ; enhanced by [RFC1123], Section 2.1\r\n   * <subdomain>       = <label> | <subdomain> \".\" <label>\r\n   * <label>           = <let-dig> [ [ <ldh-str> ] <let-dig> ]\r\n   *                     Labels must be 63 characters or less.\r\n   *                     'let-dig' not 'letter' in the first char, per RFC1123\r\n   * <ldh-str>         = <let-dig-hyp> | <let-dig-hyp> <ldh-str>\r\n   * <let-dig-hyp>     = <let-dig> | \"-\"\r\n   * <let-dig>         = <letter> | <digit>\r\n   * <letter>          = any one of the 52 alphabetic characters A through Z in\r\n   *                     upper case and a through z in lower case\r\n   * <digit>           = any one of the ten digits 0 through 9\r\n   *\r\n   * Keep support for leading dot: https://github.com/jshttp/cookie/issues/173\r\n   *\r\n   * > (Note that a leading %x2E (\".\"), if present, is ignored even though that\r\n   * character is not permitted, but a trailing %x2E (\".\"), if present, will\r\n   * cause the user agent to ignore the attribute.)\r\n   */\n\n  var domainValueRegExp = /^([.]?[a-z0-9]([a-z0-9-]{0,61}[a-z0-9])?)([.][a-z0-9]([a-z0-9-]{0,61}[a-z0-9])?)*$/i;\n\n  /**\r\n   * RegExp to match path-value in RFC 6265 sec 4.1.1\r\n   *\r\n   * path-value        = <any CHAR except CTLs or \";\">\r\n   * CHAR              = %x01-7F\r\n   *                     ; defined in RFC 5234 appendix B.1\r\n   */\n\n  var pathValueRegExp = /^[\\u0020-\\u003A\\u003D-\\u007E]*$/;\n\n  /**\r\n   * Parse a cookie header.\r\n   *\r\n   * Parse the given cookie header string into an object\r\n   * The object has the various cookies as keys(names) => values\r\n   *\r\n   * @param {string} str\r\n   * @param {object} [opt]\r\n   * @return {object}\r\n   * @public\r\n   */\n\n  function parse(str, opt) {\n    if (typeof str !== 'string') {\n      throw new TypeError('argument str must be a string');\n    }\n    var obj = {};\n    var len = str.length;\n    // RFC 6265 sec 4.1.1, RFC 2616 2.2 defines a cookie name consists of one char minimum, plus '='.\n    if (len < 2) return obj;\n    var dec = opt && opt.decode || decode;\n    var index = 0;\n    var eqIdx = 0;\n    var endIdx = 0;\n    do {\n      eqIdx = str.indexOf('=', index);\n      if (eqIdx === -1) break; // No more cookie pairs.\n\n      endIdx = str.indexOf(';', index);\n      if (endIdx === -1) {\n        endIdx = len;\n      } else if (eqIdx > endIdx) {\n        // backtrack on prior semicolon\n        index = str.lastIndexOf(';', eqIdx - 1) + 1;\n        continue;\n      }\n      var keyStartIdx = startIndex(str, index, eqIdx);\n      var keyEndIdx = endIndex(str, eqIdx, keyStartIdx);\n      var key = str.slice(keyStartIdx, keyEndIdx);\n\n      // only assign once\n      if (!__hasOwnProperty.call(obj, key)) {\n        var valStartIdx = startIndex(str, eqIdx + 1, endIdx);\n        var valEndIdx = endIndex(str, endIdx, valStartIdx);\n        if (str.charCodeAt(valStartIdx) === 0x22 /* \" */ && str.charCodeAt(valEndIdx - 1) === 0x22 /* \" */) {\n          valStartIdx++;\n          valEndIdx--;\n        }\n        var val = str.slice(valStartIdx, valEndIdx);\n        obj[key] = tryDecode(val, dec);\n      }\n      index = endIdx + 1;\n    } while (index < len);\n    return obj;\n  }\n  function startIndex(str, index, max) {\n    do {\n      var code = str.charCodeAt(index);\n      if (code !== 0x20 /*   */ && code !== 0x09 /* \\t */) return index;\n    } while (++index < max);\n    return max;\n  }\n  function endIndex(str, index, min) {\n    while (index > min) {\n      var code = str.charCodeAt(--index);\n      if (code !== 0x20 /*   */ && code !== 0x09 /* \\t */) return index + 1;\n    }\n    return min;\n  }\n\n  /**\r\n   * Serialize data into a cookie header.\r\n   *\r\n   * Serialize a name value pair into a cookie string suitable for\r\n   * http headers. An optional options object specifies cookie parameters.\r\n   *\r\n   * serialize('foo', 'bar', { httpOnly: true })\r\n   *   => \"foo=bar; httpOnly\"\r\n   *\r\n   * @param {string} name\r\n   * @param {string} val\r\n   * @param {object} [opt]\r\n   * @return {string}\r\n   * @public\r\n   */\n\n  function serialize(name, val, opt) {\n    var enc = opt && opt.encode || encodeURIComponent;\n    if (typeof enc !== 'function') {\n      throw new TypeError('option encode is invalid');\n    }\n    if (!cookieNameRegExp.test(name)) {\n      throw new TypeError('argument name is invalid');\n    }\n    var value = enc(val);\n    if (!cookieValueRegExp.test(value)) {\n      throw new TypeError('argument val is invalid');\n    }\n    var str = name + '=' + value;\n    if (!opt) return str;\n    if (null != opt.maxAge) {\n      var maxAge = Math.floor(opt.maxAge);\n      if (!isFinite(maxAge)) {\n        throw new TypeError('option maxAge is invalid');\n      }\n      str += '; Max-Age=' + maxAge;\n    }\n    if (opt.domain) {\n      if (!domainValueRegExp.test(opt.domain)) {\n        throw new TypeError('option domain is invalid');\n      }\n      str += '; Domain=' + opt.domain;\n    }\n    if (opt.path) {\n      if (!pathValueRegExp.test(opt.path)) {\n        throw new TypeError('option path is invalid');\n      }\n      str += '; Path=' + opt.path;\n    }\n    if (opt.expires) {\n      var expires = opt.expires;\n      if (!isDate(expires) || isNaN(expires.valueOf())) {\n        throw new TypeError('option expires is invalid');\n      }\n      str += '; Expires=' + expires.toUTCString();\n    }\n    if (opt.httpOnly) {\n      str += '; HttpOnly';\n    }\n    if (opt.secure) {\n      str += '; Secure';\n    }\n    if (opt.partitioned) {\n      str += '; Partitioned';\n    }\n    if (opt.priority) {\n      var priority = typeof opt.priority === 'string' ? opt.priority.toLowerCase() : opt.priority;\n      switch (priority) {\n        case 'low':\n          str += '; Priority=Low';\n          break;\n        case 'medium':\n          str += '; Priority=Medium';\n          break;\n        case 'high':\n          str += '; Priority=High';\n          break;\n        default:\n          throw new TypeError('option priority is invalid');\n      }\n    }\n    if (opt.sameSite) {\n      var sameSite = typeof opt.sameSite === 'string' ? opt.sameSite.toLowerCase() : opt.sameSite;\n      switch (sameSite) {\n        case true:\n          str += '; SameSite=Strict';\n          break;\n        case 'lax':\n          str += '; SameSite=Lax';\n          break;\n        case 'strict':\n          str += '; SameSite=Strict';\n          break;\n        case 'none':\n          str += '; SameSite=None';\n          break;\n        default:\n          throw new TypeError('option sameSite is invalid');\n      }\n    }\n    return str;\n  }\n\n  /**\r\n   * URL-decode string value. Optimized to skip native call when no %.\r\n   *\r\n   * @param {string} str\r\n   * @returns {string}\r\n   */\n\n  function decode(str) {\n    return str.indexOf('%') !== -1 ? decodeURIComponent(str) : str;\n  }\n\n  /**\r\n   * Determine if value is a Date.\r\n   *\r\n   * @param {*} val\r\n   * @private\r\n   */\n\n  function isDate(val) {\n    return __toString.call(val) === '[object Date]';\n  }\n\n  /**\r\n   * Try decoding a string using a decoding function.\r\n   *\r\n   * @param {string} str\r\n   * @param {function} decode\r\n   * @private\r\n   */\n\n  function tryDecode(str, decode) {\n    try {\n      return decode(str);\n    } catch (e) {\n      return str;\n    }\n  }\n  return cookie;\n}\nvar cookieExports = requireCookie();\nfunction hasDocumentCookie() {\n  const testingValue = typeof global === 'undefined' ? undefined : global.TEST_HAS_DOCUMENT_COOKIE;\n  if (typeof testingValue === 'boolean') {\n    return testingValue;\n  }\n  // Can we get/set cookies on document.cookie?\n  return typeof document === 'object' && typeof document.cookie === 'string';\n}\nfunction parseCookies(cookies) {\n  if (typeof cookies === 'string') {\n    return cookieExports.parse(cookies);\n  } else if (typeof cookies === 'object' && cookies !== null) {\n    return cookies;\n  } else {\n    return {};\n  }\n}\nfunction readCookie(value, options = {}) {\n  const cleanValue = cleanupCookieValue(value);\n  if (!options.doNotParse) {\n    try {\n      return JSON.parse(cleanValue);\n    } catch (e) {\n      // At least we tried\n    }\n  }\n  // Ignore clean value if we failed the deserialization\n  // It is not relevant anymore to trim those values\n  return value;\n}\nfunction cleanupCookieValue(value) {\n  // express prepend j: before serializing a cookie\n  if (value && value[0] === 'j' && value[1] === ':') {\n    return value.substr(2);\n  }\n  return value;\n}\nclass Cookies {\n  constructor(cookies, defaultSetOptions = {}) {\n    this.changeListeners = [];\n    this.HAS_DOCUMENT_COOKIE = false;\n    this.update = () => {\n      if (!this.HAS_DOCUMENT_COOKIE) {\n        return;\n      }\n      const previousCookies = this.cookies;\n      this.cookies = cookieExports.parse(document.cookie);\n      this._checkChanges(previousCookies);\n    };\n    const domCookies = typeof document === 'undefined' ? '' : document.cookie;\n    this.cookies = parseCookies(cookies || domCookies);\n    this.defaultSetOptions = defaultSetOptions;\n    this.HAS_DOCUMENT_COOKIE = hasDocumentCookie();\n  }\n  _emitChange(params) {\n    for (let i = 0; i < this.changeListeners.length; ++i) {\n      this.changeListeners[i](params);\n    }\n  }\n  _checkChanges(previousCookies) {\n    const names = new Set(Object.keys(previousCookies).concat(Object.keys(this.cookies)));\n    names.forEach(name => {\n      if (previousCookies[name] !== this.cookies[name]) {\n        this._emitChange({\n          name,\n          value: readCookie(this.cookies[name])\n        });\n      }\n    });\n  }\n  _startPolling() {\n    this.pollingInterval = setInterval(this.update, 300);\n  }\n  _stopPolling() {\n    if (this.pollingInterval) {\n      clearInterval(this.pollingInterval);\n    }\n  }\n  get(name, options = {}) {\n    if (!options.doNotUpdate) {\n      this.update();\n    }\n    return readCookie(this.cookies[name], options);\n  }\n  getAll(options = {}) {\n    if (!options.doNotUpdate) {\n      this.update();\n    }\n    const result = {};\n    for (let name in this.cookies) {\n      result[name] = readCookie(this.cookies[name], options);\n    }\n    return result;\n  }\n  set(name, value, options) {\n    if (options) {\n      options = Object.assign(Object.assign({}, this.defaultSetOptions), options);\n    } else {\n      options = this.defaultSetOptions;\n    }\n    const stringValue = typeof value === 'string' ? value : JSON.stringify(value);\n    this.cookies = Object.assign(Object.assign({}, this.cookies), {\n      [name]: stringValue\n    });\n    if (this.HAS_DOCUMENT_COOKIE) {\n      document.cookie = cookieExports.serialize(name, stringValue, options);\n    }\n    this._emitChange({\n      name,\n      value,\n      options\n    });\n  }\n  remove(name, options) {\n    const finalOptions = options = Object.assign(Object.assign(Object.assign({}, this.defaultSetOptions), options), {\n      expires: new Date(1970, 1, 1, 0, 0, 1),\n      maxAge: 0\n    });\n    this.cookies = Object.assign({}, this.cookies);\n    delete this.cookies[name];\n    if (this.HAS_DOCUMENT_COOKIE) {\n      document.cookie = cookieExports.serialize(name, '', finalOptions);\n    }\n    this._emitChange({\n      name,\n      value: undefined,\n      options\n    });\n  }\n  addChangeListener(callback) {\n    this.changeListeners.push(callback);\n    if (this.HAS_DOCUMENT_COOKIE && this.changeListeners.length === 1) {\n      if (typeof window === 'object' && 'cookieStore' in window) {\n        window.cookieStore.addEventListener('change', this.update);\n      } else {\n        this._startPolling();\n      }\n    }\n  }\n  removeChangeListener(callback) {\n    const idx = this.changeListeners.indexOf(callback);\n    if (idx >= 0) {\n      this.changeListeners.splice(idx, 1);\n    }\n    if (this.HAS_DOCUMENT_COOKIE && this.changeListeners.length === 0) {\n      if (typeof window === 'object' && 'cookieStore' in window) {\n        window.cookieStore.removeEventListener('change', this.update);\n      } else {\n        this._stopPolling();\n      }\n    }\n  }\n}\nexport { Cookies as default };","map":{"version":3,"names":["cookie","hasRequiredCookie","requireCookie","parse","serialize","__toString","Object","prototype","toString","__hasOwnProperty","hasOwnProperty","cookieNameRegExp","cookieValueRegExp","domainValueRegExp","pathValueRegExp","str","opt","TypeError","obj","len","length","dec","decode","index","eqIdx","endIdx","indexOf","lastIndexOf","keyStartIdx","startIndex","keyEndIdx","endIndex","key","slice","call","valStartIdx","valEndIdx","charCodeAt","val","tryDecode","max","code","min","name","enc","encode","encodeURIComponent","test","value","maxAge","Math","floor","isFinite","domain","path","expires","isDate","isNaN","valueOf","toUTCString","httpOnly","secure","partitioned","priority","toLowerCase","sameSite","decodeURIComponent","e","cookieExports","hasDocumentCookie","testingValue","global","undefined","TEST_HAS_DOCUMENT_COOKIE","document","parseCookies","cookies","readCookie","options","cleanValue","cleanupCookieValue","doNotParse","JSON","substr","Cookies","constructor","defaultSetOptions","changeListeners","HAS_DOCUMENT_COOKIE","update","previousCookies","_checkChanges","domCookies","_emitChange","params","i","names","Set","keys","concat","forEach","_startPolling","pollingInterval","setInterval","_stopPolling","clearInterval","get","doNotUpdate","getAll","result","set","assign","stringValue","stringify","remove","finalOptions","Date","addChangeListener","callback","push","window","cookieStore","addEventListener","removeChangeListener","idx","splice","removeEventListener","default"],"sources":["C:/Users/godls/Desktop/StackFlow-PJT/FRONT/stackflow/node_modules/universal-cookie/esm/index.mjs"],"sourcesContent":["var cookie = {};\r\n\r\n/*!\r\n * cookie\r\n * Copyright(c) 2012-2014 Roman Shtylman\r\n * Copyright(c) 2015 Douglas Christopher Wilson\r\n * MIT Licensed\r\n */\r\n\r\nvar hasRequiredCookie;\r\n\r\nfunction requireCookie () {\r\n\tif (hasRequiredCookie) return cookie;\r\n\thasRequiredCookie = 1;\r\n\r\n\t/**\r\n\t * Module exports.\r\n\t * @public\r\n\t */\r\n\r\n\tcookie.parse = parse;\r\n\tcookie.serialize = serialize;\r\n\r\n\t/**\r\n\t * Module variables.\r\n\t * @private\r\n\t */\r\n\r\n\tvar __toString = Object.prototype.toString;\r\n\tvar __hasOwnProperty = Object.prototype.hasOwnProperty;\r\n\r\n\t/**\r\n\t * RegExp to match cookie-name in RFC 6265 sec 4.1.1\r\n\t * This refers out to the obsoleted definition of token in RFC 2616 sec 2.2\r\n\t * which has been replaced by the token definition in RFC 7230 appendix B.\r\n\t *\r\n\t * cookie-name       = token\r\n\t * token             = 1*tchar\r\n\t * tchar             = \"!\" / \"#\" / \"$\" / \"%\" / \"&\" / \"'\" /\r\n\t *                     \"*\" / \"+\" / \"-\" / \".\" / \"^\" / \"_\" /\r\n\t *                     \"`\" / \"|\" / \"~\" / DIGIT / ALPHA\r\n\t */\r\n\r\n\tvar cookieNameRegExp = /^[!#$%&'*+\\-.^_`|~0-9A-Za-z]+$/;\r\n\r\n\t/**\r\n\t * RegExp to match cookie-value in RFC 6265 sec 4.1.1\r\n\t *\r\n\t * cookie-value      = *cookie-octet / ( DQUOTE *cookie-octet DQUOTE )\r\n\t * cookie-octet      = %x21 / %x23-2B / %x2D-3A / %x3C-5B / %x5D-7E\r\n\t *                     ; US-ASCII characters excluding CTLs,\r\n\t *                     ; whitespace DQUOTE, comma, semicolon,\r\n\t *                     ; and backslash\r\n\t */\r\n\r\n\tvar cookieValueRegExp = /^(\"?)[\\u0021\\u0023-\\u002B\\u002D-\\u003A\\u003C-\\u005B\\u005D-\\u007E]*\\1$/;\r\n\r\n\t/**\r\n\t * RegExp to match domain-value in RFC 6265 sec 4.1.1\r\n\t *\r\n\t * domain-value      = <subdomain>\r\n\t *                     ; defined in [RFC1034], Section 3.5, as\r\n\t *                     ; enhanced by [RFC1123], Section 2.1\r\n\t * <subdomain>       = <label> | <subdomain> \".\" <label>\r\n\t * <label>           = <let-dig> [ [ <ldh-str> ] <let-dig> ]\r\n\t *                     Labels must be 63 characters or less.\r\n\t *                     'let-dig' not 'letter' in the first char, per RFC1123\r\n\t * <ldh-str>         = <let-dig-hyp> | <let-dig-hyp> <ldh-str>\r\n\t * <let-dig-hyp>     = <let-dig> | \"-\"\r\n\t * <let-dig>         = <letter> | <digit>\r\n\t * <letter>          = any one of the 52 alphabetic characters A through Z in\r\n\t *                     upper case and a through z in lower case\r\n\t * <digit>           = any one of the ten digits 0 through 9\r\n\t *\r\n\t * Keep support for leading dot: https://github.com/jshttp/cookie/issues/173\r\n\t *\r\n\t * > (Note that a leading %x2E (\".\"), if present, is ignored even though that\r\n\t * character is not permitted, but a trailing %x2E (\".\"), if present, will\r\n\t * cause the user agent to ignore the attribute.)\r\n\t */\r\n\r\n\tvar domainValueRegExp = /^([.]?[a-z0-9]([a-z0-9-]{0,61}[a-z0-9])?)([.][a-z0-9]([a-z0-9-]{0,61}[a-z0-9])?)*$/i;\r\n\r\n\t/**\r\n\t * RegExp to match path-value in RFC 6265 sec 4.1.1\r\n\t *\r\n\t * path-value        = <any CHAR except CTLs or \";\">\r\n\t * CHAR              = %x01-7F\r\n\t *                     ; defined in RFC 5234 appendix B.1\r\n\t */\r\n\r\n\tvar pathValueRegExp = /^[\\u0020-\\u003A\\u003D-\\u007E]*$/;\r\n\r\n\t/**\r\n\t * Parse a cookie header.\r\n\t *\r\n\t * Parse the given cookie header string into an object\r\n\t * The object has the various cookies as keys(names) => values\r\n\t *\r\n\t * @param {string} str\r\n\t * @param {object} [opt]\r\n\t * @return {object}\r\n\t * @public\r\n\t */\r\n\r\n\tfunction parse(str, opt) {\r\n\t  if (typeof str !== 'string') {\r\n\t    throw new TypeError('argument str must be a string');\r\n\t  }\r\n\r\n\t  var obj = {};\r\n\t  var len = str.length;\r\n\t  // RFC 6265 sec 4.1.1, RFC 2616 2.2 defines a cookie name consists of one char minimum, plus '='.\r\n\t  if (len < 2) return obj;\r\n\r\n\t  var dec = (opt && opt.decode) || decode;\r\n\t  var index = 0;\r\n\t  var eqIdx = 0;\r\n\t  var endIdx = 0;\r\n\r\n\t  do {\r\n\t    eqIdx = str.indexOf('=', index);\r\n\t    if (eqIdx === -1) break; // No more cookie pairs.\r\n\r\n\t    endIdx = str.indexOf(';', index);\r\n\r\n\t    if (endIdx === -1) {\r\n\t      endIdx = len;\r\n\t    } else if (eqIdx > endIdx) {\r\n\t      // backtrack on prior semicolon\r\n\t      index = str.lastIndexOf(';', eqIdx - 1) + 1;\r\n\t      continue;\r\n\t    }\r\n\r\n\t    var keyStartIdx = startIndex(str, index, eqIdx);\r\n\t    var keyEndIdx = endIndex(str, eqIdx, keyStartIdx);\r\n\t    var key = str.slice(keyStartIdx, keyEndIdx);\r\n\r\n\t    // only assign once\r\n\t    if (!__hasOwnProperty.call(obj, key)) {\r\n\t      var valStartIdx = startIndex(str, eqIdx + 1, endIdx);\r\n\t      var valEndIdx = endIndex(str, endIdx, valStartIdx);\r\n\r\n\t      if (str.charCodeAt(valStartIdx) === 0x22 /* \" */ && str.charCodeAt(valEndIdx - 1) === 0x22 /* \" */) {\r\n\t        valStartIdx++;\r\n\t        valEndIdx--;\r\n\t      }\r\n\r\n\t      var val = str.slice(valStartIdx, valEndIdx);\r\n\t      obj[key] = tryDecode(val, dec);\r\n\t    }\r\n\r\n\t    index = endIdx + 1;\r\n\t  } while (index < len);\r\n\r\n\t  return obj;\r\n\t}\r\n\r\n\tfunction startIndex(str, index, max) {\r\n\t  do {\r\n\t    var code = str.charCodeAt(index);\r\n\t    if (code !== 0x20 /*   */ && code !== 0x09 /* \\t */) return index;\r\n\t  } while (++index < max);\r\n\t  return max;\r\n\t}\r\n\r\n\tfunction endIndex(str, index, min) {\r\n\t  while (index > min) {\r\n\t    var code = str.charCodeAt(--index);\r\n\t    if (code !== 0x20 /*   */ && code !== 0x09 /* \\t */) return index + 1;\r\n\t  }\r\n\t  return min;\r\n\t}\r\n\r\n\t/**\r\n\t * Serialize data into a cookie header.\r\n\t *\r\n\t * Serialize a name value pair into a cookie string suitable for\r\n\t * http headers. An optional options object specifies cookie parameters.\r\n\t *\r\n\t * serialize('foo', 'bar', { httpOnly: true })\r\n\t *   => \"foo=bar; httpOnly\"\r\n\t *\r\n\t * @param {string} name\r\n\t * @param {string} val\r\n\t * @param {object} [opt]\r\n\t * @return {string}\r\n\t * @public\r\n\t */\r\n\r\n\tfunction serialize(name, val, opt) {\r\n\t  var enc = (opt && opt.encode) || encodeURIComponent;\r\n\r\n\t  if (typeof enc !== 'function') {\r\n\t    throw new TypeError('option encode is invalid');\r\n\t  }\r\n\r\n\t  if (!cookieNameRegExp.test(name)) {\r\n\t    throw new TypeError('argument name is invalid');\r\n\t  }\r\n\r\n\t  var value = enc(val);\r\n\r\n\t  if (!cookieValueRegExp.test(value)) {\r\n\t    throw new TypeError('argument val is invalid');\r\n\t  }\r\n\r\n\t  var str = name + '=' + value;\r\n\t  if (!opt) return str;\r\n\r\n\t  if (null != opt.maxAge) {\r\n\t    var maxAge = Math.floor(opt.maxAge);\r\n\r\n\t    if (!isFinite(maxAge)) {\r\n\t      throw new TypeError('option maxAge is invalid')\r\n\t    }\r\n\r\n\t    str += '; Max-Age=' + maxAge;\r\n\t  }\r\n\r\n\t  if (opt.domain) {\r\n\t    if (!domainValueRegExp.test(opt.domain)) {\r\n\t      throw new TypeError('option domain is invalid');\r\n\t    }\r\n\r\n\t    str += '; Domain=' + opt.domain;\r\n\t  }\r\n\r\n\t  if (opt.path) {\r\n\t    if (!pathValueRegExp.test(opt.path)) {\r\n\t      throw new TypeError('option path is invalid');\r\n\t    }\r\n\r\n\t    str += '; Path=' + opt.path;\r\n\t  }\r\n\r\n\t  if (opt.expires) {\r\n\t    var expires = opt.expires;\r\n\r\n\t    if (!isDate(expires) || isNaN(expires.valueOf())) {\r\n\t      throw new TypeError('option expires is invalid');\r\n\t    }\r\n\r\n\t    str += '; Expires=' + expires.toUTCString();\r\n\t  }\r\n\r\n\t  if (opt.httpOnly) {\r\n\t    str += '; HttpOnly';\r\n\t  }\r\n\r\n\t  if (opt.secure) {\r\n\t    str += '; Secure';\r\n\t  }\r\n\r\n\t  if (opt.partitioned) {\r\n\t    str += '; Partitioned';\r\n\t  }\r\n\r\n\t  if (opt.priority) {\r\n\t    var priority = typeof opt.priority === 'string'\r\n\t      ? opt.priority.toLowerCase() : opt.priority;\r\n\r\n\t    switch (priority) {\r\n\t      case 'low':\r\n\t        str += '; Priority=Low';\r\n\t        break\r\n\t      case 'medium':\r\n\t        str += '; Priority=Medium';\r\n\t        break\r\n\t      case 'high':\r\n\t        str += '; Priority=High';\r\n\t        break\r\n\t      default:\r\n\t        throw new TypeError('option priority is invalid')\r\n\t    }\r\n\t  }\r\n\r\n\t  if (opt.sameSite) {\r\n\t    var sameSite = typeof opt.sameSite === 'string'\r\n\t      ? opt.sameSite.toLowerCase() : opt.sameSite;\r\n\r\n\t    switch (sameSite) {\r\n\t      case true:\r\n\t        str += '; SameSite=Strict';\r\n\t        break;\r\n\t      case 'lax':\r\n\t        str += '; SameSite=Lax';\r\n\t        break;\r\n\t      case 'strict':\r\n\t        str += '; SameSite=Strict';\r\n\t        break;\r\n\t      case 'none':\r\n\t        str += '; SameSite=None';\r\n\t        break;\r\n\t      default:\r\n\t        throw new TypeError('option sameSite is invalid');\r\n\t    }\r\n\t  }\r\n\r\n\t  return str;\r\n\t}\r\n\r\n\t/**\r\n\t * URL-decode string value. Optimized to skip native call when no %.\r\n\t *\r\n\t * @param {string} str\r\n\t * @returns {string}\r\n\t */\r\n\r\n\tfunction decode (str) {\r\n\t  return str.indexOf('%') !== -1\r\n\t    ? decodeURIComponent(str)\r\n\t    : str\r\n\t}\r\n\r\n\t/**\r\n\t * Determine if value is a Date.\r\n\t *\r\n\t * @param {*} val\r\n\t * @private\r\n\t */\r\n\r\n\tfunction isDate (val) {\r\n\t  return __toString.call(val) === '[object Date]';\r\n\t}\r\n\r\n\t/**\r\n\t * Try decoding a string using a decoding function.\r\n\t *\r\n\t * @param {string} str\r\n\t * @param {function} decode\r\n\t * @private\r\n\t */\r\n\r\n\tfunction tryDecode(str, decode) {\r\n\t  try {\r\n\t    return decode(str);\r\n\t  } catch (e) {\r\n\t    return str;\r\n\t  }\r\n\t}\r\n\treturn cookie;\r\n}\r\n\r\nvar cookieExports = requireCookie();\r\n\r\nfunction hasDocumentCookie() {\r\n    const testingValue = typeof global === 'undefined'\r\n        ? undefined\r\n        : global.TEST_HAS_DOCUMENT_COOKIE;\r\n    if (typeof testingValue === 'boolean') {\r\n        return testingValue;\r\n    }\r\n    // Can we get/set cookies on document.cookie?\r\n    return typeof document === 'object' && typeof document.cookie === 'string';\r\n}\r\nfunction parseCookies(cookies) {\r\n    if (typeof cookies === 'string') {\r\n        return cookieExports.parse(cookies);\r\n    }\r\n    else if (typeof cookies === 'object' && cookies !== null) {\r\n        return cookies;\r\n    }\r\n    else {\r\n        return {};\r\n    }\r\n}\r\nfunction readCookie(value, options = {}) {\r\n    const cleanValue = cleanupCookieValue(value);\r\n    if (!options.doNotParse) {\r\n        try {\r\n            return JSON.parse(cleanValue);\r\n        }\r\n        catch (e) {\r\n            // At least we tried\r\n        }\r\n    }\r\n    // Ignore clean value if we failed the deserialization\r\n    // It is not relevant anymore to trim those values\r\n    return value;\r\n}\r\nfunction cleanupCookieValue(value) {\r\n    // express prepend j: before serializing a cookie\r\n    if (value && value[0] === 'j' && value[1] === ':') {\r\n        return value.substr(2);\r\n    }\r\n    return value;\r\n}\r\n\r\nclass Cookies {\r\n    constructor(cookies, defaultSetOptions = {}) {\r\n        this.changeListeners = [];\r\n        this.HAS_DOCUMENT_COOKIE = false;\r\n        this.update = () => {\r\n            if (!this.HAS_DOCUMENT_COOKIE) {\r\n                return;\r\n            }\r\n            const previousCookies = this.cookies;\r\n            this.cookies = cookieExports.parse(document.cookie);\r\n            this._checkChanges(previousCookies);\r\n        };\r\n        const domCookies = typeof document === 'undefined' ? '' : document.cookie;\r\n        this.cookies = parseCookies(cookies || domCookies);\r\n        this.defaultSetOptions = defaultSetOptions;\r\n        this.HAS_DOCUMENT_COOKIE = hasDocumentCookie();\r\n    }\r\n    _emitChange(params) {\r\n        for (let i = 0; i < this.changeListeners.length; ++i) {\r\n            this.changeListeners[i](params);\r\n        }\r\n    }\r\n    _checkChanges(previousCookies) {\r\n        const names = new Set(Object.keys(previousCookies).concat(Object.keys(this.cookies)));\r\n        names.forEach((name) => {\r\n            if (previousCookies[name] !== this.cookies[name]) {\r\n                this._emitChange({\r\n                    name,\r\n                    value: readCookie(this.cookies[name]),\r\n                });\r\n            }\r\n        });\r\n    }\r\n    _startPolling() {\r\n        this.pollingInterval = setInterval(this.update, 300);\r\n    }\r\n    _stopPolling() {\r\n        if (this.pollingInterval) {\r\n            clearInterval(this.pollingInterval);\r\n        }\r\n    }\r\n    get(name, options = {}) {\r\n        if (!options.doNotUpdate) {\r\n            this.update();\r\n        }\r\n        return readCookie(this.cookies[name], options);\r\n    }\r\n    getAll(options = {}) {\r\n        if (!options.doNotUpdate) {\r\n            this.update();\r\n        }\r\n        const result = {};\r\n        for (let name in this.cookies) {\r\n            result[name] = readCookie(this.cookies[name], options);\r\n        }\r\n        return result;\r\n    }\r\n    set(name, value, options) {\r\n        if (options) {\r\n            options = Object.assign(Object.assign({}, this.defaultSetOptions), options);\r\n        }\r\n        else {\r\n            options = this.defaultSetOptions;\r\n        }\r\n        const stringValue = typeof value === 'string' ? value : JSON.stringify(value);\r\n        this.cookies = Object.assign(Object.assign({}, this.cookies), { [name]: stringValue });\r\n        if (this.HAS_DOCUMENT_COOKIE) {\r\n            document.cookie = cookieExports.serialize(name, stringValue, options);\r\n        }\r\n        this._emitChange({ name, value, options });\r\n    }\r\n    remove(name, options) {\r\n        const finalOptions = (options = Object.assign(Object.assign(Object.assign({}, this.defaultSetOptions), options), { expires: new Date(1970, 1, 1, 0, 0, 1), maxAge: 0 }));\r\n        this.cookies = Object.assign({}, this.cookies);\r\n        delete this.cookies[name];\r\n        if (this.HAS_DOCUMENT_COOKIE) {\r\n            document.cookie = cookieExports.serialize(name, '', finalOptions);\r\n        }\r\n        this._emitChange({ name, value: undefined, options });\r\n    }\r\n    addChangeListener(callback) {\r\n        this.changeListeners.push(callback);\r\n        if (this.HAS_DOCUMENT_COOKIE && this.changeListeners.length === 1) {\r\n            if (typeof window === 'object' && 'cookieStore' in window) {\r\n                window.cookieStore.addEventListener('change', this.update);\r\n            }\r\n            else {\r\n                this._startPolling();\r\n            }\r\n        }\r\n    }\r\n    removeChangeListener(callback) {\r\n        const idx = this.changeListeners.indexOf(callback);\r\n        if (idx >= 0) {\r\n            this.changeListeners.splice(idx, 1);\r\n        }\r\n        if (this.HAS_DOCUMENT_COOKIE && this.changeListeners.length === 0) {\r\n            if (typeof window === 'object' && 'cookieStore' in window) {\r\n                window.cookieStore.removeEventListener('change', this.update);\r\n            }\r\n            else {\r\n                this._stopPolling();\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\nexport { Cookies as default };\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}